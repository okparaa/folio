import { RecPartial, Omit } from "./shared";
export interface SyncFactoryConfig {
    readonly startingSequenceNumber?: number;
}
export type FactoryFunc<T, K extends keyof T> = keyof T extends K ? (item?: RecPartial<T>) => T : (item: RecPartial<T> & Omit<T, K>) => T;
export type ListFactoryFunc<T, K extends keyof T> = keyof T extends K ? (count: number, item?: RecPartial<T>) => T[] : (count: number, item: RecPartial<T> & Omit<T, K>) => T[];
export declare class Generator<T> {
    readonly func: (seq: number) => T;
    constructor(func: (seq: number) => T);
    build(seq: number): T;
}
export declare class Derived<TOwner, TProperty> {
    readonly func: (owner: TOwner, seq: number) => TProperty;
    constructor(func: (owner: TOwner, seq: number) => TProperty);
    build(owner: TOwner, seq: number): TProperty;
}
export interface IFactory<T, K extends keyof T> {
    build: FactoryFunc<T, K>;
    buildList: ListFactoryFunc<T, K>;
}
export declare class Factory<T, K extends keyof T = keyof T> implements IFactory<T, K> {
    readonly builder: Builder<T, K> | BuilderFactory<T, K>;
    private readonly config;
    private seqNum;
    private getStartingSequenceNumber;
    private expandBuilder;
    constructor(builder: Builder<T, K> | BuilderFactory<T, K>, config: SyncFactoryConfig | undefined);
    resetSequenceNumber(newSequenceNumber?: number): void;
    build: FactoryFunc<T, K>;
    private buildInner;
    buildList: ListFactoryFunc<T, K>;
    extend(def: RecPartial<Builder<T, K>>): Factory<T, K>;
    combine<U, K2 extends keyof U>(other: Factory<U, K2>): Factory<T & U, K | K2>;
    withSelfDerivation<KOut extends K>(kOut: KOut, f: (v1: T, seq: number) => T[KOut]): Factory<T, K>;
    withDerivation<KOut extends K>(kOut: KOut, f: (v1: T, seq: number) => T[KOut]): Factory<T, K>;
    withDerivation1<K1 extends keyof T, KOut extends keyof T>(kInput: [K1], kOut: KOut, f: (v1: T[K1], seq: number) => T[KOut]): Factory<T, K>;
    withDerivation2<K1 extends keyof T, K2 extends keyof T, KOut extends keyof T>(kInput: [K1, K2], kOut: KOut, f: (v1: T[K1], v2: T[K2], seq: number) => T[KOut]): Factory<T, K>;
    withDerivation3<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], seq: number) => T[KOut]): Factory<T, K>;
    withDerivation4<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3, K4], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], v4: T[K4], seq: number) => T[KOut]): Factory<T, K>;
    withDerivation5<K1 extends keyof T, K2 extends keyof T, K3 extends keyof T, K4 extends keyof T, K5 extends keyof T, KOut extends keyof T>(kInput: [K1, K2, K3, K4, K5], kOut: KOut, f: (v1: T[K1], v2: T[K2], v3: T[K3], v4: T[K4], v5: T[K5], seq: number) => T[KOut]): Factory<T, K>;
}
export type Builder<T, K extends keyof T = keyof T> = {
    [P in K]: T[P] | Generator<T[P]> | Derived<T, T[P]>;
};
export type BuilderFactory<T, K extends keyof T = keyof T> = () => Builder<T, K>;
export declare function val<T>(val: T): Generator<T>;
export declare function each<T>(f: (seqNum: number) => T): Generator<T>;
export declare function makeFactory<T>(builder: Builder<T> | BuilderFactory<T>, config?: SyncFactoryConfig): Factory<T>;
export declare function makeFactoryWithRequired<T, K extends keyof T>(builder: Builder<T, Exclude<keyof T, K>> | BuilderFactory<T, Exclude<keyof T, K>>, config?: SyncFactoryConfig): Factory<T, Exclude<keyof T, K>>;
